uniform vec2   iResolution;      // The resolution of current render output. It is usually a document size.
uniform float  iNormalizedTime;  // The normalized time of the current frame, from 0 to 1.
uniform int    iFrame;           // The current frame number.
uniform shader iImage;           // The Background input of the node, alternatively you can use "Background" uniform.
uniform int    iColorCount;      // 1-256: Number of colors in palette
uniform float  iDitherAmount;    // 0-1: Strength of dithering effect

// Custom modulo function since % operator isn't available
int modulo(float a, float b) {
    return int(a - (b * floor(a / b)));
}

// Get dither threshold value for current pixel
// Uses if/else chain since SKSL doesn't support dynamic array indexing
float getDitherThreshold(int x, int y) {
    // PSX dither table values
    if (y == 0) {
        if (x == 0) return 0.0 / 16.0;
        if (x == 1) return 8.0 / 16.0;
        if (x == 2) return 2.0 / 16.0;
        return 10.0 / 16.0; // x == 3
    } else if (y == 1) {
        if (x == 0) return 12.0 / 16.0;
        if (x == 1) return 4.0 / 16.0;
        if (x == 2) return 14.0 / 16.0;
        return 6.0 / 16.0; // x == 3
    } else if (y == 2) {
        if (x == 0) return 3.0 / 16.0;
        if (x == 1) return 11.0 / 16.0;
        if (x == 2) return 1.0 / 16.0;
        return 9.0 / 16.0; // x == 3
    } else { // y == 3
        if (x == 0) return 15.0 / 16.0;
        if (x == 1) return 7.0 / 16.0;
        if (x == 2) return 13.0 / 16.0;
        return 5.0 / 16.0; // x == 3
    }
}

// Apply dithering to blend between quantized levels
half4 ditherColor(half4 color, int steps, float threshold, float amount) {

    half4 stepsH4 = half4(half(steps));

    // Calculate the quantized color and the next step
    half4 lower = floor(color * stepsH4) / stepsH4;
    half4 upper = ceil(color * stepsH4) / stepsH4;
    
    // Calculate the position between the two quantized values
    half4 position = fract(color * stepsH4);
    
    // Apply dithering threshold with amount control
    half4 dithered = mix(lower, upper, step(threshold * amount, position));
    
    return dithered;
}

half4 main(vec2 coords)
{
    half4 originalColor = iImage.eval(coords);

    half4 truncatedColor = floor(originalColor * half(iColorCount)) / half(iColorCount);
    half  ditherValue    = getDitherThreshold(modulo(coords.x, 4.0), modulo(coords.y, 4.0));

    half4 dithered       = ditherColor(truncatedColor, iColorCount, ditherValue, iDitherAmount);

     // Calculate steps per channel based on desired color count

    return dithered;
}
